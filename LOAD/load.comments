0x1eb ,	comment	; Current open file? Number open files?
0x220 ,	comment	; Process PageTable
0x288 ,	comment	; Set to the user supplied boot Code
0x2a1 ,	comment	; Set to the user supplied boot Code
0x2ba ,	comment	; Set to the user supplied boot Code
0x2d3 ,	comment	; Set to the user supplied boot Code
0x2ec ,	comment	; Set to the user supplied boot Code
0x305 ,	comment	; Set to the user supplied boot Code
0x31e ,	comment	; Set to the user supplied boot Code
0x337 ,	comment	; Set to the user supplied boot Code
0x350 ,	comment	; Set to the user supplied boot Code
0x369 ,	comment	; Set to the user supplied boot Code
0x382 ,	comment	; Set to the user supplied boot Code
0x39b ,	comment	; Set to the user supplied boot Code
0x3b4 ,	comment	; Set to the user supplied boot Code
0x3cd ,	comment	; Set to the user supplied boot Code
0x3e6 ,	comment	; Set to the user supplied boot Code
0x3ff ,	comment	; Set to the user supplied boot Code
0x418 ,	comment	; Set to the user supplied boot Code
0x431 ,	comment	; Set to the user supplied boot Code
0x43e,	pre_comment 	; Null terminated list of Device objects to early-initialize at boot
0x8073,	pre_comment 	; LongCall?
0x839c ,	comment	; Calculate syscall table offset
0x839d ,	comment	; read function ptr
0x83a0 ,	comment	; modify jump instruction below
0x83a2 ,	comment	; restore registers
0x83a4 ,	comment	; jump to syscall
0x85c5 ,	comment	; 1eb
0x860a ,	comment	; Is this yield?
0x862d ,	comment	; Gets patched by Clock Routine
0x863c ,	comment	; Clear CurrentProcess
0x863e ,	comment	; Setup Temporary stack
0x8aa6,	pre_comment 	; Not entirely sure
	 	; Seems to gets the device instance struct corrosponding to byte at [B + 1]
	 	; Result in B
0x8aaf ,	comment	; 0x81
0x8ab2 ,	comment	; if B < 0x80
0x8ab5 ,	comment	; Remove top bit
0x8b26,	pre_comment 	; B is a FileOp struct
0x8b28 ,	comment	; Assert B is System Pointer
0x8b2e ,	comment	; Assert [B + 0x0006] is System pointer
0x8b3e ,	comment	; FileOp+01, device type?
0x8b45 ,	comment	; if FileOP+01 == 4
0x8b47 ,	comment	; pop DeviceInstance
0x8b49 ,	comment	; B = FileOP struct
0x8b4b ,	comment	; Special case?
0x8ce1,	pre_comment 	; arg in A, should be postive
0xa134 ,	comment	; '	 ; '	 ; '
0xa7b1 ,	comment	; '	 ; '	 ; '
0xaa27 ,	comment	; move stack down
0xaa30 ,	comment	; rearange our stack
0xaa33 ,	comment	; store X
0xabf0 ,	comment	; Return value via PC?
0xadc8 ,	comment	; Setup StackPointer
0xaedd ,	comment	; Rewrite IL0's program counter to R_aeed
0xaee0 ,	comment	; clearing IL0's context register presumably also changes it's Page Table Base
0xaee2 ,	comment	; Patch ld A, #0x0000 at 0xaf16
0xaf11 ,	comment	; Opsys Aborted
0xaf16 ,	comment	; B should be SystemInfoPtr, 01ea
0xaf27 ,	comment	; Load error device (defaults to Device_CRT0)
0xaf2b ,	comment	; Get DeviceObj
0xaf2e ,	comment	; Get Write function (default, CrtDevice_Write)
0xaf31 ,	comment	; tranfer execution to write funtion
		; Problematic, becuase this abort function hasn't set Y at all
		; and CrtDevice_Write does a lot with Y
0xaf39 ,	comment	; Abort string
0xb2d1,	pre_comment 	; Checks if A is a pointer within the kernel memory range (0x8000 to 0xefff)
	 	; Aborts if not
0xb2d7 ,	comment	; Check A is below 0x8000
0xb2e9 ,	comment	; SystemInfo_TopOfMemory
0xb2ed ,	comment	; A is above 0xefff
0xb3a2,	pre_comment 	; Writes uptime (as 32bit tenths of a second) into xarg pointer
0xb3ba,	pre_comment 	; returns uptime (as 32bit tenths of a second) in Regs A, B
0xb3d0 ,	comment	; Patches immediate in subbig
0xb3d5 ,	comment	; Mains Power Frequency
0xb3dc ,	comment	; Invert IL10(X)
0xb3e2 ,	comment	; might be divide by 6?
0xb3f0,	pre_comment 	; Writes clock into string
0xb3fd ,	comment	; Process type check?
0xb40b ,	comment	; Null termiate
0xb44b ,	comment	; Setup stack at the end of this Init function
		; We don't need it anymore, so overwrite it
0xb461,	pre_comment 	; I suspect this is the timer interrupt
	 	; So this is probally doing process switching
0xb470 ,	comment	; Not entirely sure that this is an abort
0xb473 ,	comment	; Decrement Timeslice counter
0xb474 ,	comment	; store at 0x0141
0xb483,	pre_comment 	; Update Clock
0xb488 ,	comment	; ASCII "60"
0xb4a3 ,	comment	; ASCII "24"
0xb4b0 ,	comment	; X before call
0xb4be,	pre_comment 	; Takes a two digit ASCII number in A, adds one
	 	; If the result is greater than the two digit ASCII number in X (which gets pushed
	 	; to [S] during call), then it wraps around to ascii "00"
	 	; 
0xb4be ,	comment	; A = A+1
0xb4bf ,	comment	; Ascii '9'
0xb4c7 ,	comment	; A - 10
0xb4cd ,	comment	; ascii "00"
0xb4f8,	pre_comment 	; Is hardcoded to assume Error device is a mux port
0xb500 ,	comment	; B = string
0xb506 ,	comment	; Error device
0xb509 ,	comment	; MMIO address 0xf200
0xb523 ,	comment	; Wait for UART to be ready
0xb912 ,	comment	; '	 ; '	 ; '
0xb924 ,	comment	; '	 ; '	 ; '
0xb926 ,	comment	; '	 ; '	 ; '
0xba0d ,	comment	; '	 ; '	 ; '
0xba0f ,	comment	; '	 ; '	 ; '
0xba52 ,	comment	; '	 ; '	 ; '
0xba88 ,	comment	; '	 ; '	 ; '
0xbaaf ,	comment	; '	 ; '	 ; '
0xbac2 ,	comment	; '	 ; '	 ; '
0xbad8 ,	comment	; '	 ; '	 ; '
0xbadb ,	comment	; '	 ; '	 ; '
0xbadd ,	comment	; '	 ; '	 ; '
0xbaf7 ,	comment	; '	 ; '	 ; '
0xbb03 ,	comment	; '	 ; '	 ; '
0xbb4f ,	comment	; Patch PrintStringToErrorDevice arg
0xbb77 ,	comment	; " FAIL:  X XXXX XXXX\x07\r"
0xbba1 ,	comment	; '	 ; '	 ; '
0xbbd6 ,	comment	; '	 ; '	 ; '
0xc085 ,	comment	; "EC:XX CP:XX CMDS: "
0xc27e,	pre_comment 	; X is the CRT device
	 	; Z is the WriteStruct (file operation object?)
	 	; Y is ????
0xc280 ,	comment	; Lock?
0xc290 ,	comment	; Overwrites string????
0xc2de ,	comment	; "ATTN PRINT\n\r"
0xc5a7 ,	comment	; Set exception handler's S register
		; Doesn't actually get used as a Stack
0xc5ac ,	comment	; Install exception handler
0xca1f ,	comment	; "EC:XX CMDS: "
0xcc0d ,	comment	; fixme: bad encoding?
0xcc80,	pre_comment 	; CurrentProcess + 0x32 = 8
0xcd4d,	pre_comment 	; Looks like this function converts a 16bit word to hex and writes
	 	; it to the ascii buffer specified at [X]
0xcdd1,	pre_comment 	; This is the entry point where WIPL transfers control
	 	; Z is the disk type: 0=HAWK, 1=FINCH/FLOPPY, 2=PHOENIX
0xcdd1 ,	comment	; Sense #3 jumps straight to a debugger
0xcdd5,	pre_comment 	; The code is careful to not trample too many registers before the debugger runs
	 	; But it does trample B.
0xcdd5 ,	comment	; Save return address for the debugger to exit to
0xcde1 ,	comment	; Transfer exection
0xcde4 ,	comment	; Clear context register
0xcde6 ,	comment	; Memset? all registers in other interrupt levels
0xcdec ,	comment	; Setup Stack? This isn't a very good stack pointer
0xcdf0 ,	comment	; Store the A variable that WIPL gives us
0xce09 ,	comment	; BL should now be the DISK number.
		; 0/1 for Hawk, 10/11 for Finch, 20/21 for Phoenix
0xce1d ,	comment	; Install abort handler in interrupt level 15
0xce20 ,	comment	; Set timer interrupt pagetable base to 0
0xce28 ,	comment	; Map OPSYS's page 0 to 0x7800
0xce37 ,	comment	; could this be a memcpy of 0x0000-0x07ff to 0x7800?
0xce3f ,	comment	; Map a diffrent page to 0x7800
		; I think this is the final page which will live here
0xce4c ,	comment	; memcpy 0x100 to 0xeeff???
		; Doesn't feel right for a memcpy instrution
0xce4d ,	comment	; Remap OPSYS's page0 where it should go
0xce58 ,	comment	; Not sure what this data is
0xce6c ,	comment	; StartProcess
0xce6f ,	comment	; Copy 32 entries to Page Table base 1
0xce74 ,	comment	; Copy Same 32 entries to Page Table base 3
0xce79 ,	comment	; Active page table?
0xce83 ,	comment	; Set Mux Interrupt page table base to 1
0xce88,	pre_comment 	; Zero??? all pages from page 0x1e to page 0x7d
0xce88 ,	comment	; Map page to 0xf800-0xffff
0xcea4 ,	comment	; Almost feels like this is doing a memset?
0xcea5 ,	comment	; zero upper AH regiter so we can use 16bit sub-immediate below
0xceb4 ,	comment	; map page 7f (should be MMIO regs) to 0xf800-0xffff
0xceb9 ,	comment	; Init Timer
0xcebf,	pre_comment 	; This initilizes all devices in the null-terminated EarlyInitDevices array
	 	; Which in this case is just CrtDevice_Init
0xcecc,	pre_comment 	; LOS Prompt:
0xcecd ,	comment	; "LOS 6.05 - B"
0xcee0 ,	comment	; Check if we should autoboot
0xcee5,	pre_comment 	; Asks for NAME, DISK and CODE
0xcee5 ,	comment	; "NAME="
0xcef1 ,	comment	; Will return once "NAME=" is on CRT
0xcefa ,	comment	; Will return once ReadBuffer contains user input
0xcf0c,	pre_comment 	; Loop, converting lowercase letters to uppercase
0xcf0c ,	comment	; 'a'
0xcf17 ,	comment	; 'z'
0xcf23 ,	comment	; Convert to upper case
0xcf2a ,	comment	; "DISK="
0xcf36 ,	comment	; Print "DISK="
0xcf3d ,	comment	; Read user input
0xcf46 ,	comment	; ASCII to num?
0xcf4f ,	comment	; Substract? 20
0xcf55 ,	comment	; < 20
0xcf5b ,	comment	; Disktype += 20
0xcf61 ,	comment	; Subtract? 10
0xcf69 ,	comment	; Disktype += 10
0xcf74 ,	comment	; "CODE="
0xcf80 ,	comment	; print "CODE="
0xcf8e ,	comment	; Set bit 3 on Device_CRT0+0
		; Turn off echo?
0xcf94 ,	comment	; Read user inpur
0xcfa2 ,	comment	; Clear bit 3 on Device_CRT0+0
0xcfa8 ,	comment	; Convert to Int
0xcfb8 ,	comment	; Start at first Disk Device
0xcfba,	pre_comment 	; Loop though all Devices, until we find the one matching out Disk Number
0xcfcd,	pre_comment 	; Found the correct device
0xcfd0 ,	comment	; Set the user supplied boot code
0xcfd6 ,	comment	; patch the length(?) byte of the unkblk2 instruction
0xcfd8 ,	comment	; Copy to R_e351, scanning for dot
0xcfe2 ,	comment	; space
0xcfe4 ,	comment	; Might be repacing '.' with ' '?
0xcfe5 ,	comment	; Y now points after the '.'
0xcfe7 ,	comment	; This looks like it overwrites other variables?
0xcff0 ,	comment	; filename
0xcff3 ,	comment	; Get subdirectory metadata?
0xcffc,	pre_comment 	; Successfully opened? (or found) directory?
0xcffc ,	comment	; arg1 of Syscall_4f
0xd006 ,	comment	; Type == Directory
0xd011 ,	comment	; Same as Syscall_0e, but within a subdirectory
0xd019 ,	comment	; Filename
0xd031 ,	comment	; Type == File, maybe?
0xd042 ,	comment	; Disnum
0xd047 ,	comment	; FileHandle?
0xd049,	pre_comment 	; Read Sector
0xd04e ,	comment	; Read Data out of File
0xd050 ,	comment	; 400 byte, sector size
0xd052 ,	comment	; File handle?
0xd055 ,	comment	; Sector Num
0xd059 ,	comment	; Sector count?
0xd066 ,	comment	; A load to 0x004c is counted as a configuration block
0xd06c ,	comment	; And there is a base-address at this offset
0xd074,	pre_comment 	; So this is a crazy microcoded instrution, it implements the whole inner loop of WECB loading
	 	; First argument is the base address, destinations will be calculed relative to this
	 	; Second arg is an incrementable source containing the record.
	 	; 
	 	; First byte is the type field. Known types are 0x00 and 0x01
	 	; Byte two is a length (potentially signed? @LOAD never uses a value higher than 0x78)
	 	; Bytes three and four are a Memory address
	 	; Then there are Length bytes of data
	 	; Followed by a single checksum byte
0xd080 ,	comment	; End of WECB file
0xd087 ,	comment	; Next sector
0xd08e,	pre_comment 	; Next sector
0xd08e ,	comment	; arg4
0xd0b2 ,	comment	; Disable MUX interrupt?
0xd0bb ,	comment	; This is the value in A that WIPL gave us
0xd0be ,	comment	; Jump to new entry point
0xd0c0,	pre_comment 	; Called when the user asks to load a file with type 1
0xd0ca ,	comment	; Clear the screen
0xd0cc ,	comment	; Wait until screen clear has finished
0xd0d0 ,	comment	; Switch to LOS's page0
0xd0d8 ,	comment	; "SYSTEM"
0xd0f9 ,	comment	; "TIB   "
0xd10a ,	comment	; "DISK  "
0xd11b ,	comment	; "CRT   "
0xd12c ,	comment	; "PRR   "
0xd13d ,	comment	; "SPOOL "
0xd14e ,	comment	; "LINE  "
0xd15f ,	comment	; "SPEC  "
0xd170 ,	comment	; "INVALID CONFIGURATION DATA SET\r\n"
0xd255,	pre_comment 	; Writes a string to CRT0
	 	; String is in Y, should be pointing 2 bytes into a pascal style string
0xd277 ,	comment	; set disknum
0xd665 ,	comment	; '9'
0xd66d ,	comment	; '6'
0xd675 ,	comment	; 'R'
0xd67d ,	comment	; 'H'
0xd9da ,	comment	; "OPSYS OVERSIZE-LOAD PROCESS DISCONTINUED\r\n"
0xe2b2 ,	comment	; DeviceType?
0xe311 ,	comment	; <esc><fs><ff> (escape, file seperator, form feed)
0xe35c,	pre_comment 	; This string is used as both a pascal string and a C string.
0xe49b ,	comment	; Setup CRT0 to 9600 baud
0xe4a1 ,	comment	; "*"
0xe4ac ,	comment	; "("
0xe4c3 ,	comment	; ")"
0xe4d9 ,	comment	; '\\'
0xe4db ,	comment	; Show prompt
0xe4de ,	comment	; Get command
0xe4e1 ,	comment	; 'Z'
0xe4e6 ,	comment	; 'A'
0xe4ee ,	comment	; Pointers are relative to Entry
0xe4f1 ,	comment	; Pointer Offset Table
0xe4fb ,	comment	; Pointer is positive, we just add it to Entry, and jump to it with A = 0
0xe4fc ,	comment	; Patch jmp at e521
0xe500,	pre_comment 	; Pointer is negative
	 	; These commands take arguments which this dispatcher should read.
0xe500 ,	comment	; Subtract it from Entry to get a postive offset
0xe501 ,	comment	; Patch jmp at e512
0xe506 ,	comment	; Clear X, Y and Z
0xe576 ,	comment	; save IL6's current Handler
0xe578 ,	comment	; load a new one
0xe57d ,	comment	; Allow interrupt to trigger
0xe57e ,	comment	; wait
0xe586,	pre_comment 	; Temporary IL6 interrupt handler
0xe5d6,	pre_comment 	; Mux0_WriteHexByte
	 	; Takes a Byte in A, converts to hex and writes to MUX0 with leading space
0xe5dd,	pre_comment 	; Mux0_WriteHexWord
	 	; Takes a Word in A, converts to hex and writes to MUX0 with leading space
0xe5e6 ,	comment	; Push senital byte onto stak
0xe5e8,	pre_comment 	; Loop, pushing nibbles onto stack
0xe5f2 ,	comment	; ' '
0xe5f4 ,	comment	; Write leading space
0xe5f6,	pre_comment 	; Loop, popping nibbles, converting to the range 0-F and writing to MUX0
0xe5fb ,	comment	; Stop when we see senital byte
0xe60b,	pre_comment 	; Done
0xe612,	pre_comment 	; Reads a byte from MUX0, echo it, converts to uppercase and returns in A
	 	; Stores a copy of the byte in Mux0_LastReadByte
0xe622 ,	comment	; Echo
0xe632,	pre_comment 	; Echos the last read byte (again?) from Mux0_LastReadByte
0xe644 ,	comment	; Write byte
		; B is set to 0xf200 in the above call
0xe64b ,	comment	; If byte = '\r'
0xe653 ,	comment	; also print '\n'
0xe695 ,	comment	; Check in range a
0xe700 ,	comment	; ']'
0xe74d ,	comment	; Print current register value
0xe750 ,	comment	; ]
0xe76b,	pre_comment 	; Hexdump
	 	; Y = address
	 	; 
0xe770 ,	comment	; Print Address
0xe775 ,	comment	; start_of_row
0xe77a ,	comment	; number of missing bytes for alignment
0xe77c ,	comment	; align_bytes
0xe782 ,	comment	; X = align_bytes * 3
0xe786 ,	comment	; Pad with spaces
0xe78e ,	comment	; Write byte
0xe798 ,	comment	; Continue writing bytes until end of 16 byte row
0xe79a ,	comment	; <modified> align_bytes
0xe79f ,	comment	; pad with spaces
0xe7a5 ,	comment	; <modified> start_of_row
0xe7ab ,	comment	; Set ascii high bit
0xe7b0 ,	comment	; Check for DEL
0xe7b5 ,	comment	; Check for printable
0xe7b8 ,	comment	; Replace with '^'
0xe7c1 ,	comment	; Are we past the end?
0xe7c3 ,	comment	; Next row
0xe7d1,	pre_comment 	; A memset?
	 	; Y = Start
	 	; Z = End
	 	; X = Value
0xe7f6 ,	comment	; Clear C, so our return level will be zero
0xe7fe ,	comment	; Clear IL0's C
0xe802 ,	comment	; Start executing at address 0x0100
0xe819,	pre_comment 	; This gets copied to 0x100 by above command
0xe819 ,	comment	; Load page table (below)
0xe830,	pre_comment 	; Page table
	 	; This gets copied to 0x140 by above command
0xe921 ,	comment	; Install interrupt handler into IL14
0xe935 ,	comment	; Key: A -> TosCmd_editregA
0xe937 ,	comment	; Key: B -> TosCmd_editregB
0xe939 ,	comment	; Key: C -> TosCmd_editregC
0xe93b ,	comment	; Key: D -> TosCmd_hexDump
0xe93f ,	comment	; Key: F -> TOS_CommandF
0xe941 ,	comment	; Key: G -> TOS_CommandG
0xe943 ,	comment	; Key: H -> TOS_CommandH
0xe945 ,	comment	; Key: I -> TOS_CommandI
0xe94b ,	comment	; Key: L -> TosCmd_Launch
0xe94d ,	comment	; Key: M -> TOS_CommandM
0xe94f ,	comment	; Key: N -> TOS_CommandN
0xe951 ,	comment	; Key: O -> TOS_CommandO
0xe953 ,	comment	; Key: P -> TosCmd_editregP
0xe955 ,	comment	; Key: Q -> TOS_CommandQ
0xe959 ,	comment	; Key: S -> TosCmd_editregS
0xe95b ,	comment	; Key: T -> TOS_CommandT
0xe95d ,	comment	; Key: U -> TOS_CommandU
0xe95f ,	comment	; Key: V -> TosCmd_editregV
0xe961 ,	comment	; Key: W -> TOS_CommandW
0xe963 ,	comment	; Key: X -> TosCmd_editregX
0xe965 ,	comment	; Key: Y -> TosCmd_editregY
0xe967 ,	comment	; Key: Z -> TosCmd_editregZ
