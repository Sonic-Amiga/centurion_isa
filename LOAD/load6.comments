0x1e4 ,	comment	; Length of the table in bytes
0x1e6,	pre_comment 	; This is a CRT device instances table, used by CrtDevice_Init function
	 	; The function is only called once during early init, and will initialize
	 	; all the device instances, listed here.
0x1e6 ,	comment	; The only CRT instance we have
0x1eb ,	comment	; Current open file? Number open files?
0x220 ,	comment	; Process PageTable
0x246,	pre_comment 	; CRT0 device descriptor
0x24b ,	comment	; Offset +5   - Functions table
0x24d ,	comment	; Offset +7   - device name (6 chars)
0x253 ,	comment	; Offset +0xd - process, doing the output
0x255 ,	comment	; Offset +0xf - Serial port base
0x257 ,	comment	; Offset +0x11 - device state
0x258 ,	comment	; Offset +0x12 - last written character
0x259 ,	comment	; Offset +0x13 - break (Ctrl-C) state
0x25a ,	comment	; Offset +0x14 - Current WriteStruct
0x25d ,	comment	; Offset +0x17 - BreakKey - defaults to Ctrl0C
0x25f ,	comment	; Offset +0x19 - baud rate, 0xc5 stands for 9600
0x261 ,	comment	; Offset +0x1b - low-level character read routine, called in interrupt
0x263 ,	comment	; Offset +0x1d - customization table
0x284 ,	comment	; Offset +0x13 - hardware unit number
0x288 ,	comment	; Set to the user supplied boot Code
0x29d ,	comment	; Offset +0x13 - hardware unit number
0x2a1 ,	comment	; Set to the user supplied boot Code
0x2ba ,	comment	; Set to the user supplied boot Code
0x2d3 ,	comment	; Set to the user supplied boot Code
0x2ec ,	comment	; Set to the user supplied boot Code
0x305 ,	comment	; Set to the user supplied boot Code
0x31e ,	comment	; Set to the user supplied boot Code
0x337 ,	comment	; Set to the user supplied boot Code
0x350 ,	comment	; Set to the user supplied boot Code
0x369 ,	comment	; Set to the user supplied boot Code
0x382 ,	comment	; Set to the user supplied boot Code
0x39b ,	comment	; Set to the user supplied boot Code
0x3b4 ,	comment	; Set to the user supplied boot Code
0x3cd ,	comment	; Set to the user supplied boot Code
0x3e6 ,	comment	; Set to the user supplied boot Code
0x3ff ,	comment	; Set to the user supplied boot Code
0x418 ,	comment	; Set to the user supplied boot Code
0x431 ,	comment	; Set to the user supplied boot Code
0x43e,	pre_comment 	; Null terminated list of Device objects to early-initialize at boot
0x803c ,	comment	; Get device method address
0x8040 ,	comment	; Null-check
0x8044 ,	comment	; Call it
0x8046 ,	comment	; tailcall
0x8064 ,	comment	; Switch to pagetable 0
0x8073,	pre_comment 	; Switches to pagetable base 3, with t
0x8078 ,	comment	; All entries from the Process pagetable
0x807d ,	comment	; Bottom 16 entires from PageTableTwo
0x8082 ,	comment	; Switch to pagetable 3
0x839c ,	comment	; Calculate syscall table offset
0x839d ,	comment	; read function ptr
0x83a0 ,	comment	; modify jump instruction below
0x83a2 ,	comment	; restore registers
0x83a4 ,	comment	; jump to syscall
0x85c5 ,	comment	; 1eb
0x860a ,	comment	; Is this yield?
0x862d ,	comment	; Gets patched by Clock Routine
0x863c ,	comment	; Clear CurrentProcess
0x863e ,	comment	; Setup Temporary stack
0x8805,	pre_comment 	; Returns a pointer to the current process's permission byte
0x8aa6,	pre_comment 	; Not entirely sure
	 	; Seems to gets the device instance struct corrosponding to byte at [B + 1]
	 	; Result in B
0x8aaf ,	comment	; 0x81
0x8ab2 ,	comment	; if B < 0x80
0x8ab5 ,	comment	; Remove top bit
0x8b26,	pre_comment 	; B is a FileOp struct
0x8b28 ,	comment	; Assert B is System Pointer
0x8b2e ,	comment	; Assert [B + 0x0006] is System pointer
0x8b3e ,	comment	; FileOp+01, device type?
0x8b45 ,	comment	; if FileOP+01 == 4
0x8b47 ,	comment	; pop DeviceInstance
0x8b49 ,	comment	; B = FileOP struct
0x8b4b ,	comment	; Special case?
0x8ce1,	pre_comment 	; arg in A, should be postive
0x8d21,	pre_comment 	; Might be read file. Might be open File
	 	; X+0: DiskNum
	 	; X+1: FilenamePtr
	 	; X+3: DestBuffer
	 	; X+4: arg4
	 	; Returns length in A
0x8d2d ,	comment	; Is this actually permission?
0x8d33 ,	comment	; Disknum
0x8d3c ,	comment	; Filename
0x8d3e ,	comment	; arg1
0x8d4a ,	comment	; Filename
0x8d50 ,	comment	; FileName
0x8d5e ,	comment	; Abort
0x8d66 ,	comment	; OldPermission
0x8d6b ,	comment	; DiskNum
0x8d9a,	pre_comment 	; A = FileHandle
	 	; B = DiskNum
	 	; Xarg+0 = Destination
0x8da4,	pre_comment 	; Common Tail for Syscall_02, Syscall_03 and Syscall_62
0x8da4 ,	comment	; SectorNum
0x8da8 ,	comment	; FileHandle
0x8dad ,	comment	; DiskNum
0x8dbb ,	comment	; DiskNum
0x8dbf ,	comment	; DestinationBuffer
0x8dc4 ,	comment	; arg4
0x8dc9 ,	comment	; Change stack; Overwrites strings at 8237
0x8ddb ,	comment	; Abort
0x8de4,	pre_comment 	; Not entirely sure, but this appears to be locking a mutex
0x8df4,	pre_comment 	; Syscalls 02/03/62 continued
0x8e50 ,	comment	; patched with Destination Buffer
		; Um, this decoding is suspect, it should be using P
0x9004 ,	comment	; LockMutex
0x9007 ,	comment	; Filename
0x900a ,	comment	; R_9289|0x9289
0x9036 ,	comment	; R_9289|0x9289
0xaa27 ,	comment	; move stack down
0xaa30 ,	comment	; rearange our stack
0xaa33 ,	comment	; store X
0xabf0 ,	comment	; Return value via PC?
0xadc8 ,	comment	; Setup StackPointer
0xaedd ,	comment	; Rewrite IL0's program counter to R_aeed
0xaee0 ,	comment	; clearing IL0's context register presumably also changes it's Page Table Base
0xaee2 ,	comment	; Patch ld A, #0x0000 at 0xaf16
0xaf11 ,	comment	; Opsys Aborted
0xaf16 ,	comment	; B should be SystemInfoPtr, 01ea
0xaf27 ,	comment	; Load error device (defaults to Device_CRT0)
0xaf2b ,	comment	; Get DeviceObj
0xaf2e ,	comment	; Get UrgentWrite function (default, CrtDevice_UrgentWrite)
0xaf31 ,	comment	; tranfer execution to write funtion
		; Problematic, becuase this abort function hasn't set Y at all
		; and CrtDevice_Write does a lot with Y
0xaf39 ,	comment	; Abort string
0xb2d1,	pre_comment 	; Checks if A is a pointer within the kernel memory range (0x8000 to 0xefff)
	 	; Aborts if not
0xb2d7 ,	comment	; Check A is below 0x8000
0xb2e9 ,	comment	; SystemInfo_TopOfMemory
0xb2ed ,	comment	; A is above 0xefff
0xb3a2,	pre_comment 	; Writes uptime (as 32bit tenths of a second) into xarg pointer
0xb3ba,	pre_comment 	; returns uptime (as 32bit tenths of a second) in Regs A, B
0xb3d0 ,	comment	; Patches immediate in subbig
0xb3d5 ,	comment	; Mains Power Frequency
0xb3dc ,	comment	; Invert IL10(X)
0xb3e2 ,	comment	; might be divide by 6?
0xb3f0,	pre_comment 	; Writes clock into string
0xb3fd ,	comment	; Process type check?
0xb40b ,	comment	; Null termiate
0xb44b ,	comment	; Setup stack at the end of this Init function
		; We don't need it anymore, so overwrite it
0xb461,	pre_comment 	; I suspect this is the timer interrupt
	 	; So this is probally doing process switching
0xb470 ,	comment	; Not entirely sure that this is an abort
0xb473 ,	comment	; Decrement Timeslice counter
0xb474 ,	comment	; store at 0x0141
0xb483,	pre_comment 	; Update Clock
0xb488 ,	comment	; ASCII "60"
0xb4a3 ,	comment	; ASCII "24"
0xb4b0 ,	comment	; X before call
0xb4be,	pre_comment 	; Takes a two digit ASCII number in A, adds one
	 	; If the result is greater than the two digit ASCII number in X (which gets pushed
	 	; to [S] during call), then it wraps around to ascii "00"
	 	; 
0xb4be ,	comment	; A = A+1
0xb4bf ,	comment	; Ascii '9'
0xb4c7 ,	comment	; A - 10
0xb4cd ,	comment	; ascii "00"
0xb4f8,	pre_comment 	; Is hardcoded to assume Error device is a mux port
0xb500 ,	comment	; B = string
0xb506 ,	comment	; Error device
0xb509 ,	comment	; MMIO address 0xf200
0xb523 ,	comment	; Wait for UART to be ready
0xb5a1 ,	comment	; Return addresses above 0x8000 are already privileged
0xb5a6 ,	comment	; Length
0xb5a8 ,	comment	; FileHandle
0xb5aa ,	comment	; The order of Length and handle get swapped
0xb5ae ,	comment	; The rest get copied, unmodified
0xb5f4 ,	comment	; FileHandle
0xb5f6 ,	comment	; Size
0xb5fc ,	comment	; diskNum
0xb5fe ,	comment	; Y = Device_DISKn
0xb603 ,	comment	; Couldn't find disk
0xb60b ,	comment	; SectorNum
0xb60f ,	comment	; Buffer
0xb613 ,	comment	; arg6
0xb61c ,	comment	; Arg6 & 0x80
0xb622 ,	comment	; Arg6 & 0x7f
0xb62f ,	comment	; Lock Mutex?
0xb637 ,	comment	; 0x04
0xb639 ,	comment	; Tailcall
0xb656 ,	comment	; WriteHook
0xb658,	pre_comment 	; Input translation table follows
	 	; We're mostly translating to virtual key codes. Probably this acts as a
	 	; terminal control code descriptor (yes, termcap precursor). At the moment
	 	; only the virtual code for backspace is known
0xb658 ,	comment	; 0x88 -> 0x02 VK_BACKSPACE
0xb659 ,	comment	; This also has a special designation as default backspace character
0xb65a ,	comment	; 0x85 -> 0x02 VK_BACKSPACE
0xb65c ,	comment	; 0x81 -> 0x01
0xb65e ,	comment	; 0x98 -> 0x01
0xb660 ,	comment	; 0x99 -> 0x02 VK_BACKSPACE
0xb662 ,	comment	; 0x0b -> 0x05
0xb664 ,	comment	; 0x86 -> 0x03
0xb666 ,	comment	; 0x9A -> 0x04
0xb668 ,	comment	; 0xFF -> 0x02
0xb66a ,	comment	; 0xDF -> 0x02
0xb66d ,	comment	; 0x9F -> 0xDF
0xb66f ,	comment	; 0x9d -> 0x8d
0xb6ca,	pre_comment 	; This is the actual main function, which does the job on a particular device
0xb6ca ,	comment	; X before call
0xb6cf ,	comment	; Arg6 & 0x7f - function code
0xb6d4 ,	comment	; Arg6 & 0x80 - bit 7 of the function code
0xb6d9 ,	comment	; Buffer
0xb6de ,	comment	; SectorNum
0xb6e3 ,	comment	; Y + 13
0xb6ee ,	comment	; FileHandle
0xb6f3 ,	comment	; MMIOBase
0xb6fb ,	comment	; Size
0xb703 ,	comment	; Setup PageBase2
0xb70f ,	comment	; Switch to PageBase2?
0xb71c ,	comment	; Calculate Physical Sector
0xb71f ,	comment	; Discard upper 8 bits of result, Hawk doesn't have enough sectors
0xb722 ,	comment	; patch (PhysicalSector - 1)
0xb727 ,	comment	; B = Sectors/Heads
0xb72a ,	comment	; X = Remaining Sectors/Heads in Cyclnder
0xb734 ,	comment	; Calculate Physical Sector, Again???
0xb737 ,	comment	; Cache lookup?
0xb73a ,	comment	; (PhysicalSector - 1)
0xb73e ,	comment	; increment (PhysicalSector -1)
0xb776 ,	comment	; Abort
0xb7d6 ,	comment	; AL = function code
0xb7da ,	comment	; 0 gets substitute with 0x0d
0xb7dc ,	comment	; Preserve the translated function code
0xb7e4 ,	comment	; Install interrupt handler
0xb7e6 ,	comment	; device_obj.IOBase
0xb7e9 ,	comment	; dma_mode = bits 2 and 3 of IOBase. Is it for multiple cards ?
0xb7ed ,	comment	; position into high nibble
0xb7f1 ,	comment	; Low nibble = 4
0xb7f2 ,	comment	; Patch the instruction below!
0xb7f4 ,	comment	; I wonder, why not just use register argument...
0xb7f6 ,	comment	; Enable DMA
		; At this point, DMA address and DMA count haven't been
		; set (as far as I can tell). Does this mean that enabling
		; DMA with 0 count instantly tiggeres the interrupt?
0xb803 ,	comment	; BL = function code
0xb807,	pre_comment 	; We will loop here until this inline variable becomes nonzero
0xb80b ,	comment	; AL = function code
0xb80f ,	comment	; Function code 0 prints an error message
0xb85a ,	comment	; X
0xb868 ,	comment	; IOBase
0xb86b ,	comment	; HW unit number
0xb86e ,	comment	; Select unit
0xb871 ,	comment	; Read status
0xb874 ,	comment	; Separate bits 4 and 7
0xb877 ,	comment	; We know what bit 4 is (probably) drive ready; bit 7 isn't known yet
0xb884 ,	comment	; IOBase
0xb887 ,	comment	; Unknown register
0xbb4f ,	comment	; Patch PrintStringToErrorDevice arg
0xbb77 ,	comment	; " FAIL:  X XXXX XXXX\x07\r"
0xc085 ,	comment	; "EC:XX CP:XX CMDS: "
0xc21f,	pre_comment 	; Device functions table.
	 	; The first word is the maximum (publicly) available function number. Other entries are
	 	; funnction pointer; ordinal number of the entry (starting from 0, i. e. not counting
	 	; the first word, correspond to function codes in IOStruct
	 	; UrgentWrite and Init are apparently not included in the public list (read: don't have
	 	; an operation code) and are only called directly in some special scenarios
0xc231 ,	comment	; Set first byte of the function table to 0
0xc241 ,	comment	; device_obj.state = 1
0xc25b ,	comment	; MUX_REG[8] = port_offset + 0, we don't know the purpose
0xc269 ,	comment	; jmp SwitchToPageBase0
0xc26c,	pre_comment 	; This waits for (device_obj + 0x11) to become 0
0xc276,	pre_comment 	; Normal write function
0xc278 ,	comment	; Set first byte of the function table to 0
0xc27e,	pre_comment 	; This entry point is used for error reporting (see AbortWriteStruct)
	 	; Z is the WriteStruct (file operation object?)
	 	; Y is the devce descriptor (Device_CRT0)
0xc27e ,	comment	; device_obj.state = -1. Bit 7 probably signals "output in progress"
0xc27f ,	comment	; See a waiting loop with timeout below at c2c3
0xc280 ,	comment	; This location is being manipulated by input interrupt handler
0xc283 ,	comment	; CrtDeviceHooks
0xc286 ,	comment	; Skip if not installed
0xc288 ,	comment	; Call WriteHook
0xc28c ,	comment	; Set current WriteStruct
0xc290 ,	comment	; Overwrites string????
0xc296 ,	comment	; port_offset + 1
0xc298 ,	comment	; MUX_REG[8] = port_offset + 1, we don't know the purpose
0xc29e,	pre_comment 	; This loop waits for the MUX device to be ready for transmit
0xc29e ,	comment	; MMIOBase = MUX port base address
0xc2a1 ,	comment	; Status register
0xc2a4 ,	comment	; Check TX_READY flag
0xc2a8 ,	comment	; Check whether TX timeout has passed
0xc2ab ,	comment	; Shout out if so
0xc2ad ,	comment	; Repeat the check
0xc2b5 ,	comment	; Set device_obj.Process
0xc2ba ,	comment	; [Z] = 0x80 - this will enable timeout check below
0xc2bb ,	comment	; A = MUXBase
0xc2c0 ,	comment	; MUX_REG[0x0c] = something
0xc2c3,	pre_comment 	; And here we're waiting for device_obj.state to become 0 or 1
	 	; The output is interrupt-driven, see CrtDevice_InterruptHandler
0xc2cb ,	comment	; [WriteStruct + 0] & 0x80
0xc2cc ,	comment	; Check for "receiver not ready"
0xc2cd ,	comment	; If nonzero, proceed to timeout check
0xc2d1 ,	comment	; Otherwise just reset the timeout
0xc2d4 ,	comment	; and keep waiting
0xc2de ,	comment	; "ATTN PRINT\n\r"
0xc319,	pre_comment 	; Given a serial port base address at [Y + 0x0f],
	 	; return base address of the MUX card in A
	 	; and isolated offset (relative to the base) of the port on this card in B
0xc319 ,	comment	; A = MMMIOBase = serial port base
0xc31c ,	comment	; 3 << 1
0xc31e ,	comment	; BL = bits 1 and 2 of the address AKA port offset
0xc31f ,	comment	; And this will set these bits to 0
0xc321 ,	comment	; Note port offset stays in BL
0xc325 ,	comment	; Get which port caused interrupt, this also ACKs the interrupt
0xc328 ,	comment	; Z = data register address at this point
0xc32c ,	comment	; AH = ZL & 0b110
0xc32e ,	comment	; AL = ZL & 0b11110000
0xc330 ,	comment	; AL = AH | (AL >> 1), i don't understand why. It this for more advanced MUX
0xc331 ,	comment	; with more than 4 ports ?
0xc333 ,	comment	; A = port number * 2 here
0xc338 ,	comment	; X = table length
0xc33a ,	comment	; Check if we actually have the port in the table
0xc33c ,	comment	; If yes, proceed to read
0xc33e ,	comment	; If no, read the character in order to clear the pending RX_READY
0xc341 ,	comment	; and leave silently
0xc344 ,	comment	; A = device descriptor
0xc345 ,	comment	; Bail out if nullptr
0xc347 ,	comment	; Y = device descriptor
0xc348 ,	comment	; Read one byte at (descritor + 0)
0xc349 ,	comment	; If zero, the port is considered inactive
0xc34b ,	comment	; port base address
0xc34e ,	comment	; Read the data register only to clear character pending state
0xc354 ,	comment	; device_obj.Process
0xc357 ,	comment	; Skip if not set
0xc367 ,	comment	; Does this make sure process' memory is mapped ?
0xc36c ,	comment	; Check if we have read routine set
0xc371 ,	comment	; Call if set
0xc39f ,	comment	; DISASSEMBLER BUG! Should be ld A, +0(Z) - read both status and character
0xc3a2 ,	comment	; Enside bit 7 is set in the character
0xc3a4 ,	comment	; AL is the character
0xc3a6 ,	comment	; Check bits 4 - 2 of status register, we don't know what they are
0xc3aa ,	comment	; If any of these bits is set, beep and exit
0xc3ac,	pre_comment 	; Translate a character according to a table in CrtDeviceHooks
	 	; The table consists of words. First word is an write hook, called
	 	; from within CrtDevice_Write. Other words are 2-byte entries
	 	; in format: TO FROM. The table is terminated with a zero word.
	 	; A character to translate is placed in AL, on return it will be either
	 	; translated according to the hooks table or left as it is.
0xc3ac ,	comment	; CrtDeviceHooks
0xc3af ,	comment	; Skip translation if not installed
0xc3b1 ,	comment	; Skip over write hook
0xc3b3 ,	comment	; Fetch a translation table entry (BH, BL)
0xc3b5 ,	comment	; Stop if hit the terminator word
0xc3b7 ,	comment	; char == BL
0xc3b8 ,	comment	; If doesn't match, go to next entry
0xc3ba ,	comment	; otherwise AL = translated char
0xc3bc ,	comment	; Preserve the character
0xc3bf,	pre_comment 	; Here we check for a programmable Break key, which defaults to Ctrl-C
0xc3bf ,	comment	; Check for Break key (defaults to Ctrl-C)
0xc3c3 ,	comment	; If doesn't match, proceed to TOS check
0xc3c5 ,	comment	; Check if device_obj.break_state & 0x7F == 0
0xc3ca ,	comment	; If not, just drop the character and leave
0xc3cc ,	comment	; AL = device_obj.break_state & 0x7F at this point, we know it's 0
0xc3cd ,	comment	; And now we set it to 1.
0xc3cf ,	comment	; Note that we'll only register another Break again if someone outside
0xc3d1 ,	comment	; resets the break_state back to 0
0xc3d4 ,	comment	; [0x013e]++ - global break counter
0xc3dc ,	comment	; ASCII STX (Start of Text), Ctrl-B
0xc3df ,	comment	; If not equal, proceed to handling input
0xc3e1,	pre_comment 	; This is probally a generic Secure-Attention-Key type mechnisim that always goes to the kernel
	 	; Right now, it's configured to break into the debugger, but I suspect on a retail kernel it
	 	; will be considered to do something more sane and not a secutiry flaw, like killling the current
	 	; process
0xc3e3 ,	comment	; 1a is TOS_Entry (or Debugger)
0xc3e6 ,	comment	; Check for jump instruction at TOS entry
0xc3e9 ,	comment	; Beep if no valid handler found
0xc3fa ,	comment	; Get original Return address
0xc3fc ,	comment	; Store it Tos_Return
0xc3fe ,	comment	; Replace it with return, launch TOS
0xc406 ,	comment	; ASCII BEL (bel)
0xc40d ,	comment	; Check the byte at (device_obj + 0x11)
0xc410 ,	comment	; If 0 of -1, beep and exit
0xc41d ,	comment	; AL = character
0xc41f ,	comment	; If the code is equal to 0x02...
0xc421 ,	comment	; Substitute it with something else
0xc423 ,	comment	; Restore the character back
0xc425 ,	comment	; Echo it and proceed
0xc427 ,	comment	; CrtDeviceHooks
0xc42a ,	comment	; Get backspace character
0xc42d ,	comment	; And write it to the terminal
0xc42f ,	comment	; Restore che original virtual key in AL
0xc431 ,	comment	; Proceed without echo
0xc433 ,	comment	; AL = characrter
0xc43d ,	comment	; CrtDeviceHooks
0xc440 ,	comment	; Backspace characrter
0xc44f ,	comment	; ' ' (space)
0xc453 ,	comment	; Backspace
0xc467 ,	comment	; A character is stored here
0xc495 ,	comment	; BH = [device_obj + 1]
0xc496 ,	comment	; Check "no echo" flag ???
0xc49d ,	comment	; Serial port base
0xc4a0 ,	comment	; Wait for TX_READY
0xc4aa ,	comment	; Write the character
0xc4ae ,	comment	; If (device_object + 0x11) & 0x80 == 0
0xc4b1 ,	comment	; Do nothing, just return
0xc4b6 ,	comment	; Z = device_object.CurrentWriteStruct
0xc4b7 ,	comment	; Serial port base
0xc4ba ,	comment	; Read the status register
0xc4bd ,	comment	; Check for TX_READY
0xc4bf ,	comment	; Just return if not ready
0xc4c1 ,	comment	; And this checks for bit 5 of the status
0xc4c3 ,	comment	; Is this CTS ???
0xc4c5 ,	comment	; Signal "Receiver is not ready" in the WriteStruct
0xc4c7 ,	comment	; This will be picked up by WaitForTxDone loop and it will
		; start reporting "ATTN PRINT" if this state sits for too long
0xc4c8 ,	comment	; This does some housekeeping and exits the interrupt
0xc4ca ,	comment	; WriteStruct.written
0xc4cd ,	comment	; If < 0, we're resuming from state, which was entered at 0xc4f4
0xc4cf ,	comment	; Fetch next character from the WriteStruct
0xc4d1 ,	comment	; If returned zero, we are done
0xc4d3 ,	comment	; Write the character to the terminal
0xc4d5 ,	comment	; Store device_obj.last_char
0xc4d8 ,	comment	; Was it clear screen ?
0xc4db ,	comment	; If yes, we do something strange, i don't understand it
0xc4dd ,	comment	; If it was 0xFF, we're done
0xc4e3 ,	comment	; if it's not 0x8e, we're done
0xc4e8 ,	comment	; Serial port base
0xc4eb ,	comment	; Check status register
0xc4ee ,	comment	; Check for CTS
0xc4f0 ,	comment	; Proceed if high
0xc4f2 ,	comment	; Otherwise we do strange things with our WriteRequest
0xc4f4 ,	comment	; WriteStruct.written = -1
0xc4f7 ,	comment	; device_object.status = -1
0xc4fa ,	comment	; Receiver is not ready
0xc4fc ,	comment	; device_object.state = 0
0xc4fd ,	comment	; This signals "output done"
0xc500 ,	comment	; if device_object[1] == 2, write LF
0xc507 ,	comment	; '\n'
0xc50d ,	comment	; last_char = '\r'
0xc510 ,	comment	; WriteStruct.written = 0x0fa0
0xc513 ,	comment	; I don't undeestand this
0xc516,	pre_comment 	; Here we're doint some housekeeping and leaving the interrupt
0xc516 ,	comment	; device_obj.Process
0xc51b ,	comment	; Clear some flag in the process descriptor
0xc524 ,	comment	; device_obj.WriteStruct
0xc527 ,	comment	; Z = WriteStruct
0xc52a ,	comment	; WriteStruct.written - number of characters already written
0xc52d ,	comment	; WriteStruct.ptr - pointer to a string
0xc530 ,	comment	; B = string length
0xc532 ,	comment	; Skip over already written chars
0xc534 ,	comment	; Go to next character
0xc535 ,	comment	; Check for end of buffer
0xc536 ,	comment	; Get the character if not reached
0xc53b ,	comment	; device_obj.state = 0
0xc541 ,	comment	; WriteStruct state, could be error code
0xc543 ,	comment	; Update count of written characters
0xc546 ,	comment	; Fetch the character
0xc547 ,	comment	; Pop X
0xc549 ,	comment	; The string may terminate early with 0x84
0xc5a4 ,	comment	; End of this function, Stack will overwrite it
0xc5a7 ,	comment	; Set exception handler's S register
0xc5ac ,	comment	; Install exception handler
0xc5b4 ,	comment	; A = CrtInstances
0xc5b7 ,	comment	; X = table length
0xc5b9 ,	comment	; X = length / 2 - number of instances to initialize
0xc5bc ,	comment	; A = device object (descriptor), will be Device_CRT0
0xc5c3 ,	comment	; BL = baud rate
0xc5c6 ,	comment	; Why setting twice ???
0xc5c9 ,	comment	; Should be serial port base address here
0xc5cc ,	comment	; Set baud rate
0xc5d1 ,	comment	; This should output 0x84 character
0xc5d6 ,	comment	; AL is now card address instead of a port adddess
0xc5d8 ,	comment	; Configure IPL 6 interrupt
0xc5e2 ,	comment	; MUX_REG[0x0b] = 0xe0
0xc701 ,	comment	; The first word in CRT0 descriptor points here
0xca1f ,	comment	; "EC:XX CMDS: "
0xcbca,	pre_comment 	; This function doesn't do anything new, it's just yet another form of
	 	; CallBlockRead with literal arguments. Note that number of public functions
	 	; in all disk device function tables is set to 6, and this is function #7, so
	 	; this is clearly private
0xcbcc ,	comment	; IORequest
0xcbce ,	comment	; Initial offset
0xcbd0 ,	comment	; Push initial offset
0xcbd2 ,	comment	; Push IORequest
0xcbe8 ,	comment	; Data pointer
0xcbea,	pre_comment 	; A = data pointer
0xcbea ,	comment	; Push data pointer
0xcbec ,	comment	; Get the function code - literal argumebnt
0xcbf3 ,	comment	; BL = AL & 0x80 ? 1 : 0
0xcbf5 ,	comment	; It's some flag
0xcbf9 ,	comment	; AL &= 0x7f
0xcbfb ,	comment	; Push function code
0xcbfd ,	comment	; function code > 0x02 is an error
0xcc05 ,	comment	; Function number 3 = BlockRead. Add to skip over table length
0xcc0b ,	comment	; Lock Mutex?
0xcc12 ,	comment	; A = (uint16_t)Function number
0xcc14 ,	comment	; FuncTable_offset = Function number * 2
0xcc15 ,	comment	; FuncPtr = device_obj.FuncTable + FuncTable_Offset
0xcc19 ,	comment	; Call the function
0xcc1c,	pre_comment 	; Y = device object
	 	; Z = IORequest
0xcc1e ,	comment	; Initial offset
0xcc21 ,	comment	; Push
0xcc27 ,	comment	; A = pstring16 pointer
0xcc2a ,	comment	; Skip over length
0xcc2c ,	comment	; Preserve the pointer
0xcc2e ,	comment	; Push IORequest pointer itself
0xcc30 ,	comment	; AL = unit number
0xcc36 ,	comment	; NZ = found
0xcc38 ,	comment	; If not found, it's a critical error
0xcc3f ,	comment	; A = count of written characters
0xcc42 ,	comment	; push
0xcc44 ,	comment	; Restore the data pointer in A
0xcc49,	pre_comment 	; A = device object
	 	; Z = IORequest
0xcc49 ,	comment	; Y = device_obj
0xcc4a ,	comment	; 400 - sector size
0xcc4d ,	comment	; Initial offset
0xcc51 ,	comment	; On valid if less than sector size
0xcc53 ,	comment	; Return code = invalid offset
0xcc55,	pre_comment 	; Set an IORequest completion status and return
	 	; A = error code
0xcc55 ,	comment	; IORequest[0] - is this error code ?
0xcc68 ,	comment	; jmp SwitchToPageBase0
0xcc6b ,	comment	; B = pstring16 pointer
0xcc6e ,	comment	; Set length and point to data
0xcc70 ,	comment	; Advance the data pointer to a given offset
0xcc72 ,	comment	; Store 0 at the given offset
0xcc75 ,	comment	; Function code 1 - read
0xcc76 ,	comment	; Result code 0 = OK
0xcc79,	pre_comment 	; This does not really look like Write, because it's effectively the same as Read,
	 	; but it doesn't check any IORequest fields. So, a better name could be like
	 	; RawRead, but let's keep the current name for now as a placeholder. Initially
	 	; it was chosen to correspond to CRT functions, initial of which were expected
	 	; to be the same
0xcc7c ,	comment	; Function code 2 - write
0xcc80,	pre_comment 	; This routine sets timeout, used by CheckTimeout, to 8 ticks
	 	; The actual tick time is unknown.
0xcc80 ,	comment	; 8 cycles ?
0xcc85 ,	comment	; Store timeout value
0xcc89,	pre_comment 	; This routine rolls the system clock and checks whether a timeout,
	 	; set by SetTimeout, has expired.
0xcc89 ,	comment	; Let the timeout to decrement
0xcc8e ,	comment	; Timeout value ???
0xcc91 ,	comment	; This is essentually A = !A
0xcc93 ,	comment	; Timeout ot expired
0xcc95 ,	comment	; Timeout expired
0xcc97,	pre_comment 	; This routine sets timeout, used by CheckTimeout, to 256 ticks
0xcca0,	pre_comment 	; Z = device_object
	 	; We think it's an Abort function because it writes zeroes all around
0xcca3 ,	comment	; CrtInstances
0xcca6 ,	comment	; Skip over number of entries
0xcca8,	pre_comment 	; This tries to find Z in CrtInstances table. A chunk of code is skipped
	 	; it the device appears to be not a CRT (however at least in this binary we aren't using
	 	; this function for anything else. But could be reused for a printer ?
0xcca8 ,	comment	; Hit the terminator word ?
0xccaa ,	comment	; If yes, this is not a CRT device
0xccae ,	comment	; If not, keep searching
0xccb4 ,	comment	; Serial port base
0xccb7 ,	comment	; Baud rate
0xccba ,	comment	; Set the control register
0xcce8 ,	comment	; jmp SwitchToPageBase0
0xccf2 ,	comment	; jmp SwitchToPageBase0
0xccf5,	pre_comment 	; This is also called by CrtDevice_Abort
0xcd02,	pre_comment 	; Is this a cache lookup? Or a sector remapping?
	 	; B, A = 24bit Physical Sector
	 	; Y = Device
0xcd06 ,	comment	; B = Device
0xcd0f ,	comment	; 0x05f2
0xcd18 ,	comment	; High 8 bits of sector
0xcd20 ,	comment	; lower 16bits of Sector
0xcd27 ,	comment	; Device
0xcd2a ,	comment	; B = Total tracks on disk
0xcd31,	pre_comment 	; Shift Total Tracks up by 4, overflowig into A (which gets discarded, anyway)
0xcd4d,	pre_comment 	; Looks like this function converts a 16bit word to hex and writes
	 	; it to the ascii buffer specified at [X]
0xcd67,	pre_comment 	; A is sectorNum
	 	; B is FileHandle
	 	; B + 0 is 16bit file size (in sectors)
	 	; B + 4 is 8bit bits per cluster???
	 	; B + 1b onwards is a list of 24 bit cluster??? addresses
0xcd72 ,	comment	; Read is beyond end of file
0xcd7b ,	comment	; bits per cluster?
0xcd7e ,	comment	; rotate 16 bits, total
0xcd87 ,	comment	; Shift bits out of bottom A
0xcd88 ,	comment	; And into top of X
0xcd8a ,	comment	; Until we have shited out [B+4] bits
0xcd8c ,	comment	; Continue shifting X to correctly align
0xcd91 ,	comment	; X should be offset within Sector
0xcd93 ,	comment	; A should be Sector Num
0xcd95 ,	comment	; B = A * 3
0xcd96 ,	comment	; A = FileHandle
0xcd98 ,	comment	; B += FileHandle
0xcdbb ,	comment	; Not found, set Z flag
0xcdc0 ,	comment	; Subtract or Compare
0xcdc6 ,	comment	; Device type != 4
0xcdcc ,	comment	; Device Num = DeviceNum
0xcdd1,	pre_comment 	; This is the entry point where WIPL transfers control
	 	; Z is the disk type: 0=HAWK, 1=FINCH/FLOPPY, 2=PHOENIX
0xcdd1 ,	comment	; Sense #3 jumps straight to a debugger
0xcdd5,	pre_comment 	; The code is careful to not trample too many registers before the debugger runs
	 	; But it does trample B.
0xcdd5 ,	comment	; Save return address for the debugger to exit to
0xcde1 ,	comment	; Transfer exection
0xcde4 ,	comment	; Clear context register
0xcde6 ,	comment	; Memset? all registers in other interrupt levels
0xcdec ,	comment	; Setup Stack? This isn't a very good stack pointer
0xcdf0 ,	comment	; Store the A variable that WIPL gives us
0xce09 ,	comment	; BL should now be the DISK number.
		; 0/1 for Hawk, 10/11 for Finch, 20/21 for Phoenix
0xce1d ,	comment	; Install abort handler in interrupt level 15
0xce20 ,	comment	; Set timer interrupt pagetable base to 0
0xce28 ,	comment	; Map OPSYS's page 0 to 0x7800
0xce37 ,	comment	; could this be a memcpy of 0x0000-0x07ff to 0x7800?
0xce3f ,	comment	; Map a diffrent page to 0x7800
		; I think this is the final page which will live here
0xce4c ,	comment	; Read/Write every single byte from 0x0100 to 0xeeff, to initilize parity bits
0xce4d ,	comment	; Remap OPSYS's page0 where it should go
0xce58 ,	comment	; Not sure what this data is
0xce6c ,	comment	; StartProcess
0xce6f ,	comment	; Copy 32 entries to Page Table base 1
0xce74 ,	comment	; Copy Same 32 entries to Page Table base 3
0xce79 ,	comment	; Active page table?
0xce83 ,	comment	; Set Mux Interrupt page table base to 1
0xce88,	pre_comment 	; Detect memory.
	 	; Scans memory, 2KB pages at a time until it finds a page that doesn't hold values
0xce88 ,	comment	; Map page to 0xf800-0xffff
0xce8f ,	comment	; write/read 0 to 0xffff
0xce90 ,	comment	; Check it matches
0xce94 ,	comment	; A = 0xffff
0xce97 ,	comment	; write/read 0xff to 0xffff
0xce9a ,	comment	; check it matces
0xce9c ,	comment	; Y = 0xf800
0xcea4 ,	comment	; Copy each byte to itself, to initilize the parity bits
0xcea5 ,	comment	; zero upper AH regiter so we can use 16bit sub-immediate below
0xceb4,	pre_comment 	; Finished memory detection
0xceb4 ,	comment	; map page 7f (should be MMIO regs) to 0xf800-0xffff
0xceb9 ,	comment	; Init Timer
0xcebf,	pre_comment 	; This initilizes all devices in the null-terminated EarlyInitDevices array
	 	; Which in this case is just CrtDevice_Init
0xcec3 ,	comment	; Init routine
0xcec6 ,	comment	; Go to a next device if missing
0xcec8 ,	comment	; Call the init routine
0xceca ,	comment	; Go to a next device
0xcecc,	pre_comment 	; LOS Prompt:
0xcecd ,	comment	; "LOS 6.05 - B"
0xcee0 ,	comment	; Check if we should autoboot
0xcee5,	pre_comment 	; Asks for NAME, DISK and CODE
0xcee5 ,	comment	; "NAME="
0xcef1 ,	comment	; Will return once "NAME=" is on CRT
0xcefa ,	comment	; Will return once ReadBuffer contains user input
0xcf0c,	pre_comment 	; Loop, converting lowercase letters to uppercase
0xcf0c ,	comment	; 'a'
0xcf17 ,	comment	; 'z'
0xcf23 ,	comment	; Convert to upper case
0xcf2a ,	comment	; "DISK="
0xcf36 ,	comment	; Print "DISK="
0xcf3d ,	comment	; Read user input
0xcf46 ,	comment	; ASCII to num?
0xcf4f ,	comment	; Substract? 20
0xcf55 ,	comment	; < 20
0xcf5b ,	comment	; Disktype += 20
0xcf61 ,	comment	; Subtract? 10
0xcf69 ,	comment	; Disktype += 10
0xcf74 ,	comment	; "CODE="
0xcf80 ,	comment	; print "CODE="
0xcf8e ,	comment	; Set bit 3 on Device_CRT0+0
		; Turn off echo?
0xcf94 ,	comment	; Read user inpur
0xcfa2 ,	comment	; Clear bit 3 on Device_CRT0+0
0xcfa8 ,	comment	; Convert to Int
0xcfb8 ,	comment	; Start at first Disk Device
0xcfba,	pre_comment 	; Loop though all Devices, until we find the one matching out Disk Number
0xcfcd,	pre_comment 	; Found the correct device
0xcfd0 ,	comment	; Set the user supplied boot code
0xcfd6 ,	comment	; patch the length(?) byte of the unkblk2 instruction
0xcfd8 ,	comment	; Copy to R_e351, scanning for dot
0xcfe2 ,	comment	; space
0xcfe4 ,	comment	; Might be repacing '.' with ' '?
0xcfe5 ,	comment	; Y now points after the '.'
0xcfe7 ,	comment	; This looks like it overwrites other variables?
0xcff0 ,	comment	; filename
0xcff3 ,	comment	; Get subdirectory metadata?
0xcffc,	pre_comment 	; Successfully opened? (or found) directory?
0xcffc ,	comment	; arg1 of Syscall_4f
0xd006 ,	comment	; Type == Directory
0xd011 ,	comment	; Same as Syscall_0e, but within a subdirectory
0xd019 ,	comment	; Filename
0xd028 ,	comment	; patch FileHandle of ReadConfiration's Read syscall
0xd031 ,	comment	; 1, Configuration filetype
0xd038 ,	comment	; 4 Binary file type
0xd042 ,	comment	; Disnum
0xd047 ,	comment	; FileHandle?
0xd049,	pre_comment 	; Read Sector
0xd049 ,	comment	; Load OPSYS page before doing syscall
0xd04e ,	comment	; Read Data out of file into ReadBuffer
0xd050 ,	comment	; 400 byte, sector size
0xd052 ,	comment	; File handle?
0xd055 ,	comment	; Sector Num
0xd059 ,	comment	; Sector count?
0xd05a ,	comment	; LOS_Page0 is potentially empty before this load?
0xd066 ,	comment	; A load to 0x004c is counted as a configuration sector
0xd06c ,	comment	; And there is a base-address at this offset
0xd074,	pre_comment 	; So this is a crazy microcoded instruction, it appears to implement the whole inner loop of
	 	; WECB record loading
	 	; 
	 	; This is how I think the instruction should work:
	 	; First argument is the base address, destinations will be calculated relative to this
	 	; Second arg is an implementable source containing the record.
	 	; 
	 	; First byte is the type field. Known types are 0x00 and 0x01
	 	; Byte two is a length (potentially signed? @LOAD never uses a value higher than 0x78)
	 	; Bytes three and four are a RecordAddress
	 	; Then there <Length> bytes of data will follow
	 	; Followed by a single checksum byte. The checksum is calculated as:
	 	; 0x100 - sum(all header/data bytes)
	 	; 
	 	; In a type 0 record, the data is simply copied to RecordAddress (plus BaseAddress)
	 	; A zero-length type 0 record is valid, and should copy no data
	 	; WECB files use a zero-length record at the end to indicate the entry address
	 	; In a type 1 record, the data is one or more 16bit fixup addresses.
	 	; For each 16bit FixupAddress, the microcode should:
	 	; FixupAddress = BaseAddress+BaseAddress
	 	; FixupValue = 16bit load from Fixup address
	 	; FixupValue = FixupValue + RecordAddress + BaseAddress
	 	; Write FixupValue back to FixupAddress
	 	; 
	 	; On completion:
	 	; Fault flag should be set if there was an error
	 	; Carry flag should be set depending on some condition (record length > 0x80?)
	 	; A = RecordAddress + BaseAddress
	 	; Z = pointer to next record
0xd079 ,	comment	; Check fault flag
0xd07e ,	comment	; Something causes the microcode to set carry, and it means next sector.
0xd080 ,	comment	; End of WECB file
0xd087 ,	comment	; Next record type, Next sector
0xd08c ,	comment	; next record is something other than 0x80, go back to microcode
0xd08e,	pre_comment 	; Next sector
0xd08e ,	comment	; modify arg4 of Syscall_4c
0xd094,	pre_comment 	; Loading complete, transfer execution to loaded binary
0xd0a2 ,	comment	; clear ISR
0xd0a4 ,	comment	; Decoded wrong. should be "ld_dma_mode 0",
0xd0ac ,	comment	; Clear timer interrupt handler
		; If the timer is still going, the new binary will need
		; to disable or install a new handler before enabling
		; interrupts
0xd0af ,	comment	; Reset MUX interrupt
0xd0ba ,	comment	; A is binary entrypoint from microcode
0xd0bb ,	comment	; This is the value in A that WIPL gave us
0xd0be ,	comment	; Jump to new entry point
0xd0c0,	pre_comment 	; Called when the user asks to load a file with type 1
0xd0ca ,	comment	; Clear the screen
0xd0cc ,	comment	; Wait until screen clear has finished
0xd0d0 ,	comment	; Switch to LOS's page0
0xd0d5 ,	comment	; Read data (and do some other stuff)
0xd0d8 ,	comment	; "SYSTEM"
0xd0e4 ,	comment	; ERROR
0xd0e7 ,	comment	; "SYSTEM" + two extra chars
0xd0e9 ,	comment	; A string of variables
		; Mostly contains counts for each config entry type
0xd0f9 ,	comment	; "TIB   "
0xd10a ,	comment	; "DISK  "
0xd11b ,	comment	; "CRT   "
0xd12c ,	comment	; "PRR   "
0xd13d ,	comment	; "SPOOL "
0xd14e ,	comment	; "LINE  "
0xd15f ,	comment	; "SPEC  "
0xd170 ,	comment	; "INVALID CONFIGURATION DATA SET\r\n"
0xd188,	pre_comment 	; First, the next (ConfigEchoLineCount) entries should be echoed to the CRT
0xd188 ,	comment	; Part of the bulk read after System
0xd190 ,	comment	; Write it to screen
0xd199,	pre_comment 	; Setup a bunch of fixed values in lower mem, and allocate data structures
0xd199 ,	comment	; This is all happening on LOS Page0, so it won't effect the current' running OPSYS
0xd19f ,	comment	; Jump instruction
0xd1b0 ,	comment	; 107 is a pointer to a two byte object
0xd1dc ,	comment	; PageTable
0xd1e3 ,	comment	; PageTable
0xd1f4 ,	comment	; TIBs are two bytes each?
0xd215 ,	comment	; B should be number of devices (plus 2)
0xd217 ,	comment	; Truncate upper bits?
0xd219 ,	comment	; B should be 2*num_devices, size of Devices array
0xd255,	pre_comment 	; Writes a string to CRT0
	 	; String is in Y, should be pointing 2 bytes into a pascal style string
	 	; Which is the layout that ReadNextConfigEntry returns
0xd277 ,	comment	; set disknum
0xd279,	pre_comment 	; Read Sector Loop
0xd280 ,	comment	; 400 bytes
0xd282 ,	comment	; FileHandle Patched before ReadConfigurationDataset was called
0xd285 ,	comment	; Sector
0xd293,	pre_comment 	; The caller should update Y to point past the end of the the previous entry
0xd294 ,	comment	; Disable Timeout, so OPSYS won't kill us
		; The Configuration Dataset file format appears to be a sequence of Pascal style strings
		; If the length starts with 0xff (so probally -1?) Skip to the next sector
0xd29e ,	comment	; Skip to next sector if the next byte is 0xff
0xd2a2 ,	comment	; Read Sector Loop
0xd2a4,	pre_comment 	; The Configuration Dataset file format ends with a two byte string, starting with ASCII EOT
0xd2a4 ,	comment	; check for magic end of file marker
0xd2c3 ,	comment	; SystemProcess? SystemObject?
0xd316 ,	comment	; Each TIB is 0x5c
0xd325 ,	comment	; loop, Next TIB
0xd3d8 ,	comment	; Flags, Type
0xd3df ,	comment	; Disknum
0xd665 ,	comment	; '9'
0xd66d ,	comment	; '6'
0xd675 ,	comment	; 'R'
0xd67d ,	comment	; 'H'
0xd7c4 ,	comment	; Buffer
0xd7f7 ,	comment	; Buffer?
0xd802 ,	comment	; Disknum
0xd803 ,	comment	; Filename
0xd805 ,	comment	; Buffer
0xd88a ,	comment	; Patched at d86a
0xd9da ,	comment	; "OPSYS OVERSIZE-LOAD PROCESS DISCONTINUED\r\n"
0xd9ec ,	comment	; SpinForever
0xd9ee ,	comment	; Syscall entry point
0xda03 ,	comment	; @SYS.OSN
0xda26 ,	comment	; Zero memory usage table
0xe121,	pre_comment 	; 400 bytes of data space for I/O operations
0xe2b1 ,	comment	; Offset 0 - result code (set by the driver)
0xe2b2 ,	comment	; Offset 1 - DeviceType?
0xe2b4 ,	comment	; Offset 3 - function code = Write
0xe2b5 ,	comment	; Offset 4 - probably starting offset into the text
0xe2b7 ,	comment	; Offset 6 - pstring16 pointer
0xe2b9 ,	comment	; ; Offset 8 - processed characters counter
0xe2be ,	comment	; Function code = Read
0xe311 ,	comment	; <esc><fs><ff> (escape, file seperator, form feed)
0xe35c,	pre_comment 	; This string is used as both a pascal string and a C string.
0xe49b ,	comment	; Setup CRT0 to 9600 baud
0xe4a1 ,	comment	; "*"
0xe4ac ,	comment	; "("
0xe4c3 ,	comment	; ")"
0xe4d9 ,	comment	; '\\'
0xe4db ,	comment	; Show prompt
0xe4de ,	comment	; Get command
0xe4e1 ,	comment	; 'Z'
0xe4e6 ,	comment	; 'A'
0xe4ee ,	comment	; Pointers are relative to Entry
0xe4f1 ,	comment	; Pointer Offset Table
0xe4fb ,	comment	; Pointer is positive, we just add it to Entry, and jump to it with A = 0
0xe4fc ,	comment	; Patch jmp at e521
0xe500,	pre_comment 	; Pointer is negative
	 	; These commands take arguments which this dispatcher should read.
0xe500 ,	comment	; Subtract it from Entry to get a postive offset
0xe501 ,	comment	; Patch jmp at e512
0xe506 ,	comment	; Clear X, Y and Z
0xe576 ,	comment	; save IL6's current Handler
0xe578 ,	comment	; load a new one
0xe57d ,	comment	; Allow interrupt to trigger
0xe57e ,	comment	; wait
0xe586,	pre_comment 	; Temporary IL6 interrupt handler
0xe5d6,	pre_comment 	; Mux0_WriteHexByte
	 	; Takes a Byte in A, converts to hex and writes to MUX0 with leading space
0xe5dd,	pre_comment 	; Mux0_WriteHexWord
	 	; Takes a Word in A, converts to hex and writes to MUX0 with leading space
0xe5e6 ,	comment	; Push senital byte onto stak
0xe5e8,	pre_comment 	; Loop, pushing nibbles onto stack
0xe5f2 ,	comment	; ' '
0xe5f4 ,	comment	; Write leading space
0xe5f6,	pre_comment 	; Loop, popping nibbles, converting to the range 0-F and writing to MUX0
0xe5fb ,	comment	; Stop when we see senital byte
0xe60b,	pre_comment 	; Done
0xe612,	pre_comment 	; Reads a byte from MUX0, echo it, converts to uppercase and returns in A
	 	; Stores a copy of the byte in Mux0_LastReadByte
0xe622 ,	comment	; Echo
0xe632,	pre_comment 	; Echos the last read byte (again?) from Mux0_LastReadByte
0xe644 ,	comment	; Write byte
		; B is set to 0xf200 in the above call
0xe64b ,	comment	; If byte = '\r'
0xe653 ,	comment	; also print '\n'
0xe695 ,	comment	; Check in range a
0xe700 ,	comment	; ']'
0xe74d ,	comment	; Print current register value
0xe750 ,	comment	; ]
0xe76b,	pre_comment 	; Hexdump
	 	; Y = address
	 	; 
0xe770 ,	comment	; Print Address
0xe775 ,	comment	; start_of_row
0xe77a ,	comment	; number of missing bytes for alignment
0xe77c ,	comment	; align_bytes
0xe782 ,	comment	; X = align_bytes * 3
0xe786 ,	comment	; Pad with spaces
0xe78e ,	comment	; Write byte
0xe798 ,	comment	; Continue writing bytes until end of 16 byte row
0xe79a ,	comment	; <modified> align_bytes
0xe79f ,	comment	; pad with spaces
0xe7a5 ,	comment	; <modified> start_of_row
0xe7ab ,	comment	; Set ascii high bit
0xe7b0 ,	comment	; Check for DEL
0xe7b5 ,	comment	; Check for printable
0xe7b8 ,	comment	; Replace with '^'
0xe7c1 ,	comment	; Are we past the end?
0xe7c3 ,	comment	; Next row
0xe7d1,	pre_comment 	; A memset?
	 	; Y = Start
	 	; Z = End
	 	; X = Value
0xe7f6 ,	comment	; Clear C, so our return level will be zero
0xe7fe ,	comment	; Clear IL0's C
0xe802 ,	comment	; Start executing at address 0x0100
0xe819,	pre_comment 	; This gets copied to 0x100 by above command
0xe819 ,	comment	; Load page table (below)
0xe830,	pre_comment 	; Page table
	 	; This gets copied to 0x140 by above command
0xe921 ,	comment	; Install interrupt handler into IL14
0xe935 ,	comment	; Key: A -> TosCmd_editregA
0xe937 ,	comment	; Key: B -> TosCmd_editregB
0xe939 ,	comment	; Key: C -> TosCmd_editregC
0xe93b ,	comment	; Key: D -> TosCmd_hexDump
0xe93f ,	comment	; Key: F -> TOS_CommandF
0xe941 ,	comment	; Key: G -> TOS_CommandG
0xe943 ,	comment	; Key: H -> TOS_CommandH
0xe945 ,	comment	; Key: I -> TOS_CommandI
0xe94b ,	comment	; Key: L -> TosCmd_Launch
0xe94d ,	comment	; Key: M -> TOS_CommandM
0xe94f ,	comment	; Key: N -> TOS_CommandN
0xe951 ,	comment	; Key: O -> TOS_CommandO
0xe953 ,	comment	; Key: P -> TosCmd_editregP
0xe955 ,	comment	; Key: Q -> TOS_CommandQ
0xe959 ,	comment	; Key: S -> TosCmd_editregS
0xe95b ,	comment	; Key: T -> TOS_CommandT
0xe95d ,	comment	; Key: U -> TOS_CommandU
0xe95f ,	comment	; Key: V -> TosCmd_editregV
0xe961 ,	comment	; Key: W -> TOS_CommandW
0xe963 ,	comment	; Key: X -> TosCmd_editregX
0xe965 ,	comment	; Key: Y -> TosCmd_editregY
0xe967 ,	comment	; Key: Z -> TosCmd_editregZ
