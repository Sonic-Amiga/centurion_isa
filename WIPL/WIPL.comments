0x108,	pre_comment 	; Entry point
0x109 ,	comment	; Initialize some vars
0x118 ,	comment	; 0xc5
0x11a ,	comment	; Patch ld AL, #0xc5 instruction at addr 043c
0x11d ,	comment	; Patch ld BL, #0xc5 instruction at addr 056d
0x120 ,	comment	; Initialize stack
0x124 ,	comment	; This sends RTZ command to our disks.
0x138,	pre_comment 	; We go here if sense1 switch is set (DIAG board is present)
0x138 ,	comment	; The binary is clearly corrupt here
0x141,	pre_comment 	; Self-modifying code ahead!!!
	 	; The function at L_014b probes for 8 units on a DSK board at base address (AL << 16) + 0x40
	 	; and, if successful, sends an RTZ command.
	 	; These four stores patch the base address in the code below
0x141 ,	comment	; 14c
0x143 ,	comment	; 152
0x145 ,	comment	; 015d
0x147 ,	comment	; 0163
0x149 ,	comment	; Start probing from unit 7
0x14b,	pre_comment 	; Probe drive units from 7 to 0 and send RTZ command to connected ones
0x14b ,	comment	; Unit select
0x14e ,	comment	; BL = 0 (RTZ), BH = value to check flags against
0x151 ,	comment	; Read command register ??? Some flaga ???
0x154 ,	comment	; command_reg & 0x30
0x158 ,	comment	; Should be 0x30. If not, skip this unit (not present)
0x15c ,	comment	; RTZ (recalibrate)
0x162 ,	comment	; Wait for command_reg & 0x30 == 0x30; this indicates drive ready
0x16b ,	comment	; Next unit, down to 0
0x16f,	pre_comment 	; Continuation of boot process
0x173 ,	comment	; DX = 4096
0x174,	pre_comment 	; This locates end of RAM, effectively probing how much RAM we've got
0x174 ,	comment	; Preserve original (RT) value
0x175 ,	comment	; Try to store 0xff
0x178 ,	comment	; Load it back
0x179 ,	comment	; Exit if we got zero (failed to store)
0x17b ,	comment	; Put original value back
0x17c ,	comment	; RT += 4096 (page size ?)
0x17e ,	comment	; Reached 0xf000 ?
0x183 ,	comment	; Repeat until we reach 0xf000
0x185 ,	comment	; Store final address of our RAM
0x18c ,	comment	; This looks like a severely corrupt binary, can't continue
0x1bb,	pre_comment 	; The code jumps here when for instance empty string was entered on CODE prompt
	 	; According to known behavior, thus jumps back to WIPL prompt, effectively
	 	; restarting it
0x1ce ,	comment	; WIPL version string
0x1d7 ,	comment	; "NAME"
0x1dc ,	comment	; name_buffer
0x1e1 ,	comment	; "DISK"
0x1e6 ,	comment	; disk_buffer
0x1eb ,	comment	; "CODE"
0x1f5 ,	comment	; code_buffer
0x242 ,	comment	; code_buffer
0x24d,	pre_comment 	; EX points at the first non-numeric character after the code
0x24d ,	comment	; Store entered_disk_code
0x250 ,	comment	; Track 0 side 0 sector 15
0x257,	pre_comment 	; EX is an address of the loaded sector
0x257 ,	comment	; Disk format flag
0x25a ,	comment	; Must be equal to 0xff
0x25b ,	comment	; Proceed to disk code checking
0x261 ,	comment	; Incorrect disk format
0x265 ,	comment	; This is a "check disk code" flag.
		; If zero, the check will be bypassed.
0x266 ,	comment	; Disk code is derived from this value
0x26a ,	comment	; This whole thing rotates AX right WITHOUT carry
0x273 ,	comment	; Some more obfuscation
0x278 ,	comment	; BX is the final expected value here
0x27a ,	comment	; This is "request check" flag. We don't know how/where it's set.
0x27d ,	comment	; If not zero, the check is required
0x27f ,	comment	; entered_disk_code = expected_entered_disk_code
0x282 ,	comment	; Bypass
0x284,	pre_comment 	; Check the disk code
0x284 ,	comment	; AX - entered_disk_code
0x287 ,	comment	; BX = expected_disk_code
0x288 ,	comment	; Proceed if there's a match
0x28e ,	comment	; Incorrect disk code
0x293,	pre_comment 	; Disk code is correct
	 	; Note we're doing some further manipulations with it, i don't get the
	 	; point, LoadSector routine doesn't use AX and BX, in fact it will overwrite them.
0x29d ,	comment	; entered_disk_code
0x2a5,	pre_comment 	; RT is also not changed here. Are we reloading 0x000e ? This is strange...
0x33d ,	comment	; This variable stores end of RAM
0x363 ,	comment	; name_buffer
0x374 ,	comment	; disk_buffer
0x378 ,	comment	; code_buffer
0x3bd,	pre_comment 	; This function converts one hexadecimal digit from its ASCII representation
	 	; to value. Result is returned in BL.
0x3c2 ,	comment	; -1 is returned on error
0x3c9,	pre_comment 	; Parses a numeric string, pointed to by EX, and returns the
	 	; parsed value in AX. EX is updated to point at the first non-digit character
0x3c9 ,	comment	; Check the first character
0x3ce ,	comment	; The character is invalid
0x3d1,	pre_comment 	; A correcr digit has been entered
0x3d2 ,	comment	; value = 0
0x3d4 ,	comment	; Do the conversion again, increment pointer this time
0x3da ,	comment	; Invalid character, restore the pointer
		; It now points behind our number
0x3dc ,	comment	; return value
0x3df ,	comment	; AX = value
0x3e0 ,	comment	; (SP) = digit
0x3e2 ,	comment	; BX = value << 1
0x3e3 ,	comment	; should be sll AX, 2
0x3e5 ,	comment	; BX = (value << 1) + (value << 3) = value * 10
0x3e6 ,	comment	; AX = digit
0x3e8 ,	comment	; BX += digit
0x3e9 ,	comment	; value = value * 10 + digit
0x43e ,	comment	; This should jump to 0x125, but that isn't a valid location
		; Most likely our binary is corrupt around here
0x4a6 ,	comment	; 400 bytes == 1 sector
0x4b0,	pre_comment 	; This function loads one sector from the drive.
	 	; CHS address of the sector to read needs to be placed into X (RT) register
	 	; in HAWK native format (CCCCCCCC CCCHSSSS) before calling this function.
	 	; This routine uses two buffers, whose addresses are stored in two
	 	; variables above. The buffer to use is chosen by the literal byte
	 	; argument: 0 or 1. Address of the buffer is returned in EX.
0x4b3 ,	comment	; EX = DSK_BASE
0x4b4 ,	comment	; AX = LoadBuffer0
0x4b8 ,	comment	; If literal argument is not 0...
0x4ba ,	comment	; .. then AX = LoadBuffer1
0x4bc ,	comment	; Preserve loading address (patch instruction at 04cd)
0x4be ,	comment	; Setup DMA to read
0x4c4 ,	comment	; READ command
0x4c9,	pre_comment 	; Upon completion status register value will be in AX
0x4c9 ,	comment	; Check HAWK_STATUS & 0x0100
0x4cb ,	comment	; If bit set, recalibrate, seek and retry (read error)
0x4cd ,	comment	; AX = loading address (this insn is patched)
0x4d4 ,	comment	; RTZ command
0x4dd ,	comment	; AX = loading address (from the patched insn)
0x4df ,	comment	; Retry
0x4ea ,	comment	; Write sector address register
0x4ed ,	comment	; SEEK command
0x4f5,	pre_comment 	; This location is only called when READ operation is initiated.
	 	; I suggest it waits for data transfer to end.
0x4f5 ,	comment	; HAWK status
0x4f8 ,	comment	; Wait for STATUS & 0x01 == 0
0x4fb,	pre_comment 	; And this waits for a generic operation completion
0x4fb ,	comment	; HAWK status
0x4fe ,	comment	; Wait for STATUS & 0x30 == 0x30
0x609,	pre_comment 	; This routine supposedly reads a line from the terminal
